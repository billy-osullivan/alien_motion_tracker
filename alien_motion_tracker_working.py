# Raspberry Pi based motion tracker
# Runs on pygame and python3
# HC-SR04 Ultra Sonic sensors x 3 used
# Will run on any 40pin Raspberry Pi
#
# Prototype created by SHEDTECH on behalf of
# WEYLAND-YUTANI corp. - Building Better Worlds
#
# Author:			Billy O Sullivan
# Created date:		20 June 2022
# Edited:			06 July 2022
#
#
# Switch 1, SW1, controls the mode. At present there are 2 modes:
# mode 1 is a demo mode that simulates motion with pre programmed motion
# mode 2 takes motion from the sensors.
#
# Switch 2, SW2, controls the sound. The sound is generated by a 3 volt buzzer.
# by default the buzzer is on. push SW2 to turn it off.
#
# Future improvements will add the following modes and functionality (if i get time):
# mode 3 will use only the center sensor only
# mode 4 will use the left and right sensors only
#
# Functionality might also be added to change the sensitivity from 1cm to
# 25cm or 50cm if both sw1 and sw2 are pressed together a few times.
#
###################################

# import libraries
import pygame
import RPi.GPIO as GPIO
import time

# set up GPIO
# GPIO Mode (BOARD / BCM)
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False) # Ignore warning
# set GPIO Pins
DEV1_GPIO_TRIGGER = 27
DEV1_GPIO_ECHO = 4
DEV2_GPIO_TRIGGER = 24
DEV2_GPIO_ECHO = 23
DEV3_GPIO_TRIGGER = 6
DEV3_GPIO_ECHO = 5
SW1 = 20
SW2 = 21
BUZ = 26
# set GPIO direction (IN / OUT)
GPIO.setup(DEV1_GPIO_TRIGGER, GPIO.OUT)
GPIO.setup(DEV2_GPIO_TRIGGER, GPIO.OUT)
GPIO.setup(DEV3_GPIO_TRIGGER, GPIO.OUT)
GPIO.setup(DEV1_GPIO_ECHO, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(DEV2_GPIO_ECHO, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(DEV3_GPIO_ECHO, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(SW1, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(SW2, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(BUZ, GPIO.OUT)

# Define some colors that we can use on the display
DARKDARKGREEN = (3, 21, 2)
LIGHTGREEN = (0, 255, 0)
GREEN = (0, 128, 0)
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
YELLOW = (173,255,47)
OFFWHITE = (191,191,191)
RED = (255,0,0)

# define screen size
SCREEN_WIDTH = 720
SCREEN_HEIGHT = 720

# function to read sensor
def distancereading1():
	# set Trigger to HIGH
	GPIO.output(DEV1_GPIO_TRIGGER, True)
	# set Trigger after 0.01ms to LOW
	time.sleep(0.00001)
	GPIO.output(DEV1_GPIO_TRIGGER, False)
	StartTime = time.time()
	StopTime = time.time()
	# save StartTime
	while GPIO.input(DEV1_GPIO_ECHO) == 0:
		StartTime = time.time()
	# save time of arrival
	while GPIO.input(DEV1_GPIO_ECHO) == 1:
		StopTime = time.time()
	# time difference between start and arrival
	TimeElapsed = StopTime - StartTime
	# multiply with the sonic speed (34300 cm/s)
	# and divide by 2, because there and back
	distance = (TimeElapsed * 34300) / 2
	return distance

# function to read sensor
def distancereading2():
	# set Trigger to HIGH
	GPIO.output(DEV2_GPIO_TRIGGER, True)
	# set Trigger after 0.01ms to LOW
	time.sleep(0.00001)
	GPIO.output(DEV2_GPIO_TRIGGER, False)
	StartTime = time.time()
	StopTime = time.time()
	# save StartTime
	while GPIO.input(DEV2_GPIO_ECHO) == 0:
		StartTime = time.time()
	# save time of arrival
	while GPIO.input(DEV2_GPIO_ECHO) == 1:
		StopTime = time.time()
	# time difference between start and arrival
	TimeElapsed = StopTime - StartTime
	# multiply with the sonic speed (34300 cm/s)
	# and divide by 2, because there and back
	distance = (TimeElapsed * 34300) / 2
	return distance

# function to read sensor
def distancereading3():
	# set Trigger to HIGH
	GPIO.output(DEV3_GPIO_TRIGGER, True)
	# set Trigger after 0.01ms to LOW
	time.sleep(0.00001)
	GPIO.output(DEV3_GPIO_TRIGGER, False)
	StartTime = time.time()
	StopTime = time.time()
	# save StartTime
	while GPIO.input(DEV3_GPIO_ECHO) == 0:
		StartTime = time.time()
	# save time of arrival
	while GPIO.input(DEV3_GPIO_ECHO) == 1:
		StopTime = time.time()
	# time difference between start and arrival
	TimeElapsed = StopTime - StartTime
	# multiply with the sonic speed (34300 cm/s)
	# and divide by 2, because there and back
	distance = (TimeElapsed * 34300) / 2
	return distance

# pygame sets the x,y zero point in the top left corner
# function to display blip
def distancecenter(distance1, screen):
	# FURTHEST DISTANCE CENTER
	# DISTANCE1
	if distance1 > 499:
		pygame.draw.circle(screen, OFFWHITE, [360, 80], 20)
		pygame.draw.circle(screen, OFFWHITE, [335, 80], 20)
		pygame.draw.circle(screen, OFFWHITE, [385, 80], 20)
		pygame.draw.circle(screen, OFFWHITE, [360, 65], 20)
	# largest distance in the graph center
	if distance1 > 332 and distance1 < 500:
		pygame.draw.circle(screen, OFFWHITE, [360, 200], 20)
		pygame.draw.circle(screen, OFFWHITE, [335, 200], 20)
		pygame.draw.circle(screen, OFFWHITE, [385, 200], 20)
		pygame.draw.circle(screen, OFFWHITE, [360, 185], 20)
	# middle distance in the graph center
	if distance1 > 165 and distance1 < 333:
		pygame.draw.circle(screen, OFFWHITE, [360, 340], 15)
		pygame.draw.circle(screen, OFFWHITE, [340, 340], 15)
		pygame.draw.circle(screen, OFFWHITE, [380, 340], 15)
		pygame.draw.circle(screen, OFFWHITE, [360, 325], 15)
	# short distance in the graph center
	if distance1 > 49 and distance1 < 166:
		pygame.draw.circle(screen, RED, [360, 480], 15)
	# short distance in the graph center
	if distance1 < 50:
		pygame.draw.circle(screen, RED, [360, 590], 20)

# function to display blip
def distanceleft(distance2, screen):
	# FURTHEST DISTANCE LEFT
	# DISTANCE2
	if distance2 > 500:
		pygame.draw.circle(screen, OFFWHITE, [120, 130], 20)
		pygame.draw.circle(screen, OFFWHITE, [95, 130], 20)
		pygame.draw.circle(screen, OFFWHITE, [145, 130], 20)
		pygame.draw.circle(screen, OFFWHITE, [120, 115], 20)
	# largest distance in the graph LEFT
	if distance2 > 332 and distance2 < 500:
		pygame.draw.circle(screen, OFFWHITE, [180, 230], 20)
		pygame.draw.circle(screen, OFFWHITE, [155, 230], 20)
		pygame.draw.circle(screen, OFFWHITE, [205, 230], 20)
		pygame.draw.circle(screen, OFFWHITE, [180, 215], 20)
	# middle distance in the graph LEFT
	if distance2 > 165 and distance2 < 333:
		pygame.draw.circle(screen, OFFWHITE, [240, 350], 15)
		pygame.draw.circle(screen, OFFWHITE, [250, 360], 15)
		pygame.draw.circle(screen, OFFWHITE, [230, 360], 15)
	# short distance in the graph LEFT
	if distance2 > 49 and distance2 < 166:
		pygame.draw.circle(screen, RED, [310, 490], 15)
	# short distance in the graph LEFT
	if distance2 < 50:
		pygame.draw.circle(screen, RED, [360, 590], 20)

# function to display blip
def distanceright(distance3, screen):
	# FURTHEST DISTANCE RIGHT
	# DISTANCE3
	if distance3 > 500:
		pygame.draw.circle(screen, OFFWHITE, [600, 130], 20)
		pygame.draw.circle(screen, OFFWHITE, [575, 130], 20)
		pygame.draw.circle(screen, OFFWHITE, [625, 130], 20)
		pygame.draw.circle(screen, OFFWHITE, [600, 115], 20)
	# largest distance in the graph RIGHT
	if distance3 > 332 and distance3 < 500:
		pygame.draw.circle(screen, OFFWHITE, [540, 230], 20)
		pygame.draw.circle(screen, OFFWHITE, [515, 230], 20)
		pygame.draw.circle(screen, OFFWHITE, [565, 230], 20)
		pygame.draw.circle(screen, OFFWHITE, [540, 215], 20)
	# middle distance in the graph RIGHT
	if distance3 > 165 and distance3 < 333:
		pygame.draw.circle(screen, OFFWHITE, [480, 350], 15)
		pygame.draw.circle(screen, OFFWHITE, [490, 360], 15)
		pygame.draw.circle(screen, OFFWHITE, [470, 360], 15)
	# short distance in the graph RIGHT
	if distance3 > 49 and distance3 < 166:
		pygame.draw.circle(screen, RED, [410, 490], 15)
	# short distance in the graph RIGHT
	if distance3 < 50:
		pygame.draw.circle(screen, RED, [360, 590], 20)

############################################
def main():
	# set up variables
	loop_counter = 1
	demo_count = 0
	mode = 1
	sound = 1
	arc_x = 360
	arc_y = 590
	arc_width = 0.1
	arc_height = 0.1

	pygame.init()
	# hide mouse icon
	pygame.mouse.set_visible(False)
	# Set the height and width of the screen
	size = [SCREEN_WIDTH, SCREEN_HEIGHT]

	# set up the screen and its size
	screen = pygame.display.set_mode(size)
	#pygame.display.set_caption("Motion Tracker v1.0")

	# Loop until the user clicks the close button.
	done = False

	# Used to manage how fast the screen updates
	clock = pygame.time.Clock()

	#################   Main Program Loop   ###################
	while not done:
		# Event Processing to quit
		for event in pygame.event.get():
			if event.type == pygame.QUIT:
				done = True

		# scan button for mode change
		if GPIO.input(SW1) == GPIO.LOW:
			time.sleep(.5)
			if mode == 1:
				mode = 2
			else:
				mode = 1
		# scan button for mode change
		if GPIO.input(SW2) == GPIO.LOW:
			time.sleep(.5)
			if sound == 1:
				sound = 2
				GPIO.output(BUZ, False)
			else:
				sound = 1

		# Set the screen background
		screen.fill(DARKDARKGREEN)

		# draw red lights at left side of screen
		pygame.draw.rect(screen, RED, pygame.Rect(10, 72, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(10, 144, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(10, 216, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(10, 288, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(10, 360, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(10, 432, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(10, 504, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(10, 576, 10, 5))

		# draw red lights at right side of screen
		pygame.draw.rect(screen, RED, pygame.Rect(700, 72, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(700, 144, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(700, 216, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(700, 288, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(700, 360, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(700, 432, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(700, 504, 10, 5))
		pygame.draw.rect(screen, RED, pygame.Rect(700, 576, 10, 5))

		# draw circle for start of radar
		pygame.draw.circle(screen, GREEN, [360, 590], 30)
		# DRAW AN ARC
		# arc(surface, color, rect, start_angle, stop_angle, width=1)
		# rect is the following:
		# x,y coordinates, width and height
		pygame.draw.arc(screen, GREEN, [225, 380, 275,220], 0.5236, 2.618, 4)
		pygame.draw.arc(screen, GREEN, [137, 250, 455, 350], 0.5236, 2.618, 4)
		pygame.draw.arc(screen, GREEN, [40, 100, 650, 500], 0.5236, 2.618, 4)

		# draw the radar grid lines
		pygame.draw.line(screen, GREEN, [360, 590], [85,225], 6)
		pygame.draw.line(screen, GREEN, [360, 590], [645,225], 6)
		pygame.draw.line(screen, GREEN, [360, 590], [230, 122], 2)
		pygame.draw.line(screen, GREEN, [360, 590], [505, 125], 2)

		# control blip noise with the buzzer
		if sound == 1:
			if loop_counter > 1 and loop_counter < 15:
				GPIO.output(BUZ, True)
			else:
				GPIO.output(BUZ, False)

		# draw the arc animation
		if loop_counter <=75:
			pygame.draw.arc(screen, WHITE, [arc_x, arc_y, arc_width, arc_height], 0.5236, 2.618,4)
			arc_x = arc_x - 4.45
			arc_y = arc_y - 6.58
			arc_width = arc_width + 9.1
			arc_height = arc_height + 5.75
		elif loop_counter >75:
			loop_counter = 1
			arc_x = 360
			arc_y = 590
			arc_width = 0.1
			arc_height = 0.1

		# mode 1 is a demo mode that will output data without
		# using any sensors
		if mode == 1:
			fontdemo = pygame.font.SysFont(None, 30)
			imgdemo = fontdemo.render('DEMO', True, WHITE)
			screen.blit(imgdemo, (150, 20))
			demo_count = demo_count + 1
			if demo_count < 180:
				distance1 = 600
				distance2 = 400
				distance3 = 300
				# Range will show the closest reading
				fontdemorange = pygame.font.SysFont(None, 30)
				imgdemorange = fontdemorange.render('300', True, WHITE)
				screen.blit(imgdemorange, (360, 650))
			elif demo_count > 179 and demo_count < 660:
				distance1 = 400
				distance2 = 300
				distance3 = 400
				# Range will show the closest reading
				fontdemorange = pygame.font.SysFont(None, 30)
				imgdemorange = fontdemorange.render('300', True, WHITE)
				screen.blit(imgdemorange, (360, 650))
			elif demo_count > 659 and demo_count < 1260:
				distance1 = 300
				distance2 = 90
				distance3 = 300
				# Range will show the closest reading
				fontdemorange = pygame.font.SysFont(None, 30)
				imgdemorange = fontdemorange.render('90', True, WHITE)
				screen.blit(imgdemorange, (360, 650))
			elif demo_count > 1259 and demo_count < 1560:
				distance1 = 90
				distance2 = 300
				distance3 = 150
				# Range will show the closest reading
				fontdemorange = pygame.font.SysFont(None, 30)
				imgdemorange = fontdemorange.render('90', True, WHITE)
				screen.blit(imgdemorange, (360, 650))
			elif demo_count > 1559 and demo_count < 1800:
				distance1 = 30
				distance2 = 600
				distance3 = 300
				# Range will show the closest reading
				fontdemorange = pygame.font.SysFont(None, 30)
				imgdemorange = fontdemorange.render('30', True, RED)
				screen.blit(imgdemorange, (360, 650))
			else:
				demo_count = 0
		# mode 2 will read from the 3 sensors
		else:
			fontdemo = pygame.font.SysFont(None, 30)
			imgdemo = fontdemo.render('LIVE', True, WHITE)
			screen.blit(imgdemo, (150, 20))
			if loop_counter == 25:
				distance1 = distancereading3()
				distance2 = distancereading2()
				distance3 = distancereading1()
				# Range will show the closest reading
			if distance1 < distance2 and distance1 < distance3:
				if distance1 < 50:
					fontdemorange = pygame.font.SysFont(None, 30)
					imgdemorange = fontdemorange.render(str(int(distance1)), True, RED)
					screen.blit(imgdemorange, (360, 650))
				else:
					fontdemorange = pygame.font.SysFont(None, 30)
					imgdemorange = fontdemorange.render(str(int(distance1)), True, WHITE)
					screen.blit(imgdemorange, (360, 650))
			elif distance2 < distance3:
				if distance2 < 50:
					fontdemorange = pygame.font.SysFont(None, 30)
					imgdemorange = fontdemorange.render(str(int(distance2)), True, RED)
					screen.blit(imgdemorange, (360, 650))
				else:
					fontdemorange = pygame.font.SysFont(None, 30)
					imgdemorange = fontdemorange.render(str(int(distance2)), True, WHITE)
					screen.blit(imgdemorange, (360, 650))
			else:
				if distance3 < 50:
					fontdemorange = pygame.font.SysFont(None, 30)
					imgdemorange = fontdemorange.render(str(int(distance3)), True, RED)
					screen.blit(imgdemorange, (360, 650))
				else:
					fontdemorange = pygame.font.SysFont(None, 30)
					imgdemorange = fontdemorange.render(str(int(distance3)), True, WHITE)
					screen.blit(imgdemorange, (360, 650))

		distancecenter(distance1, screen)
		distanceleft(distance2, screen)
		distanceright(distance3, screen)

		loop_counter = loop_counter + 1

		font = pygame.font.SysFont(None, 30)
		img = font.render('MODE:', True, YELLOW)
		font1 = pygame.font.SysFont(None, 30)
		img1 = font1.render('RANGE:', True, YELLOW)
		font2 = pygame.font.SysFont(None, 30)
		img2 = font2.render('TRACKING:', True, YELLOW)
		font3 = pygame.font.SysFont(None, 30)
		img3 = font3.render('REFRESH RATE: 1Hz', True, YELLOW)
		font4 = pygame.font.SysFont(None, 30)
		img4 = font4.render('SENSITIVITY: 1cm', True, YELLOW)
		screen.blit(img, (60, 20))
		screen.blit(img1, (270, 650))
		screen.blit(img3, (430, 20))
		screen.blit(img4, (60, 50))
		# Limit to 60 frames per second
		clock.tick(60)

		# Go ahead and update the screen with what we've drawn.
		pygame.display.flip()

	# Close everything down
	pygame.quit()

if __name__ == "__main__":
	main()


